<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinic Queuing Problem Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Added Prism CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <!-- Added MathJax for formula rendering -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Adjusted code block padding as Prism adds its own */
        .code-block {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        /* Custom styles for animation status */
        .status-free { background-color: #dcfce7; color: #166534; } /* green-100, green-800 */
        .status-busy { background-color: #ffedd5; color: #9a3412; } /* orange-100, orange-800 */
        
        /* Styles for the new timeline */
        .timeline-marker {
            position: absolute;
            top: 50%;
            width: 10px;
            height: 10px;
            background-color: #94a3b8; /* slate-400 */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: background-color 0.3s ease;
            z-index: 10;
        }
        .timeline-marker.active {
            background-color: #4f46e5; /* indigo-600 */
        }
        /* New style for patients who have to wait */
        .timeline-marker.waited.active {
            background-color: #f97316; /* orange-500 */
        }

        /* Styles for beautiful log */
        .log-entry {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0.25rem;
            border-left: 4px solid;
            transition: background-color 0.2s;
            border-radius: 0 0.25rem 0.25rem 0;
        }
        .log-start { border-color: #6b7280; background-color: rgba(107, 114, 128, 0.05); } /* gray */
        .log-arrival-immediate { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.05); } /* blue */
        .log-arrival-queue { border-color: #f97316; background-color: rgba(249, 115, 22, 0.05); } /* orange */
        .log-service { border-color: #22c55e; background-color: rgba(34, 197, 94, 0.05); } /* green */
        .log-end { border-color: #ef4444; background-color: rgba(239, 68, 68, 0.05); } /* red */

        .home-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: #2c3e50;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        .home-button:hover {
            background: #34495e;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <a href="../index.html" class="home-button">
        ← Home
    </a>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-slate-900">Clinic Queuing Simulation</h1>
            <p class="text-lg text-slate-600 mt-2">An interactive breakdown of a classic queuing problem.</p>
        </header>

        <main class="space-y-8">
            
            <!-- The Question Card -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-slate-900 border-b pb-2">The Queuing Problem</h2>
                <div class="prose max-w-none text-slate-700 space-y-4">
                    <p>A clinic has three doctors. Patients come into the clinic at random, starting at 9 a.m., according to a Poisson process with a time parameter of 10 minutes. When a patient arrives, they wait until a doctor is available. The time spent by each doctor with each patient is a random variable, uniformly distributed between 5 and 20 minutes.</p>
                    <p>The office stops admitting new patients at 4 p.m. and closes only when the last patient is finished with their doctor.</p>
                </div>
            </div>

            <!-- The Math Explanation Card -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-slate-900 border-b pb-2">The Math Behind the Simulation</h2>
                <div class="prose max-w-none text-slate-700 space-y-4">
                    <p>The simulation uses two different probability distributions to model the randomness of the real world. Understanding these is key to seeing how the simulation works.</p>

                    <h3 class="font-semibold text-lg text-slate-800 pt-2">1. Patient Arrivals: The Exponential Distribution</h3>
                    <p>This distribution is used to answer the question: "How long until the <em>next</em> random event happens?" It's the perfect model for the time between independent, random events, like patients walking into a clinic. The key idea is that the process has no "memory"—the time of the last arrival has no impact on the next one. This is what the term <strong>Poisson Process</strong> implies.</p>
                    
                    <h4 class="font-medium text-md text-slate-800">The Formula:</h4>
                    <p>The probability of the waiting time `x` is described by the Probability Density Function (PDF):
                        $$f(x; \lambda) = \lambda e^{-\lambda x}$$
                        Where `\(\lambda\)` (lambda) is the <strong>rate parameter</strong>, representing the average number of events per unit of time. The problem states the average time between arrivals is 10 minutes. Since the mean is `\(1/\lambda\)`, our rate `\(\lambda\)` is `1/10` or 0.1 patients per minute.
                    </p>

                    <h3 class="font-semibold text-lg text-slate-800 pt-2">2. Doctor's Service Time: The Uniform Distribution</h3>
                    <p>This is the most straightforward distribution. It's used when any outcome within a specific range is <strong>equally likely</strong>. For our clinic, it means a doctor's appointment is just as likely to last 6 minutes as it is to last 19 minutes, or any other time between 5 and 20 minutes.</p>

                    <h4 class="font-medium text-md text-slate-800">The Formula:</h4>
                    <p>The Probability Density Function (PDF) is a simple constant for any value `x` between a minimum `a` and a maximum `b`:
                        $$f(x) = \frac{1}{b - a}$$
                        For our simulation, with `a=5` and `b=20`, the formula becomes `\(f(x) = 1/(20-5) = 1/15\)`. This constant value means all service times in the range are equally probable.
                    </p>
                </div>
            </div>

            <!-- The Animation Card -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-slate-900">Live Simulation</h2>
                    <button id="run-animation-btn" class="bg-indigo-600 text-white font-semibold px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 w-48">
                        Run Animation
                    </button>
                </div>
                
                <!-- Visual Status Display -->
                <div id="visual-status" class="bg-slate-50 p-4 rounded-md mb-4 border border-slate-200">
                    <div class="flex justify-between items-center text-lg font-semibold mb-3">
                        <span class="text-slate-800">Clinic Status</span>
                        <span id="sim-clock" class="px-3 py-1 bg-slate-200 rounded-full text-sm text-slate-700">Time: 09:00</span>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <h3 class="font-semibold mb-2 text-slate-700">Doctors</h3>
                            <div id="doctors-status" class="space-y-2">
                                <!-- Doctor divs will be generated by JS -->
                            </div>
                        </div>
                        <div>
                            <h3 class="font-semibold mb-2 text-slate-700">Waiting Queue</h3>
                            <div id="queue-status" class="flex items-center space-x-1 flex-wrap h-16">
                                <span id="queue-text" class="text-slate-500">Empty</span>
                            </div>
                        </div>
                    </div>
                    <!-- Timeline Section -->
                    <div class="mt-4 pt-4 border-t border-slate-200">
                            <h3 class="font-semibold mb-3 text-slate-700">Patient Arrival Timeline</h3>
                            <div id="timeline-container" class="relative h-10 flex items-center">
                                <div id="timeline-bar" class="w-full h-2 bg-slate-300 rounded-full relative">
                                    <div id="timeline-progress" class="absolute top-0 left-0 h-2 bg-indigo-400 rounded-full" style="width: 0%;"></div>
                                    <!-- Markers will be added here by JS -->
                                </div>
                            </div>
                            <div class="flex justify-between w-full text-xs text-slate-500 mt-1 px-1">
                                <span id="timeline-start-label">9 AM</span>
                                <span id="timeline-end-label">5 PM</span>
                            </div>
                    </div>
                    <!-- Summary Stats Section -->
                    <div id="summary-stats" class="mt-4 pt-4 border-t border-slate-200 text-center grid grid-cols-2 gap-4">
                        <div>
                            <h4 class="text-sm font-semibold text-slate-600">Total Patients Visited</h4>
                            <p id="patient-count" class="text-2xl font-bold text-indigo-600">0</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-slate-600">Clinic Closed At</h4>
                            <p id="closing-time" class="text-2xl font-bold text-indigo-600">--:--</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-slate-600">Total Wait Time</h4>
                            <p id="total-wait-time" class="text-2xl font-bold text-indigo-600">0m</p>
                        </div>
                        <div>
                            <h4 class="text-sm font-semibold text-slate-600">Average Wait Time</h4>
                            <p id="avg-wait-time" class="text-2xl font-bold text-indigo-600">0.0m</p>
                        </div>
                    </div>
                </div>

                <p class="text-slate-600 mb-4">A step-by-step event log of the simulated day.</p>
                <div id="animation-output" class="code-block h-80 overflow-y-scroll text-sm !p-2">
                    Click "Run Animation" to begin...
                </div>
            </div>

            <!-- The Python Solution Card -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-slate-900 border-b pb-2">The Python Solution</h2>
                <div class="code-block text-sm">
<pre><code class="language-python">
import random
import math
import numpy as np

# --- Simulation Parameters ---
NUM_DOCTORS = 3
MEAN_ARRIVAL_TIME = 10.0
MIN_SERVICE_TIME = 5.0
MAX_SERVICE_TIME = 20.0
SIMULATION_START_TIME = 9 * 60
ADMISSIONS_END_TIME = 16 * 60

# --- Helper Function ---
def format_time(minutes):
    hours = int(minutes // 60)
    mins = int(minutes % 60)
    return f"{hours:02d}:{mins:02d}"

# --- Core Simulation Logic ---
def run_single_simulation():
    doctor_free_times = [SIMULATION_START_TIME] * NUM_DOCTORS
    patient_queue = []
    next_arrival_time = SIMULATION_START_TIME + random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
    
    total_patients_arrived = 0
    patients_who_waited = 0
    total_wait_time = 0.0
    last_patient_finish_time = SIMULATION_START_TIME

    while next_arrival_time <= ADMISSIONS_END_TIME or patient_queue:
        earliest_free_time = min(doctor_free_times)
        next_free_doctor_idx = doctor_free_times.index(earliest_free_time)

        if next_arrival_time < earliest_free_time and next_arrival_time <= ADMISSIONS_END_TIME:
            current_time = next_arrival_time
            total_patients_arrived += 1
            patient_queue.append(current_time)
            next_arrival_time += random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
        else:
            current_time = earliest_free_time
            if patient_queue:
                patient_arrival_time = patient_queue.pop(0)
                wait_time = current_time - patient_arrival_time
                patients_who_waited += 1
                total_wait_time += wait_time
                
                service_time = random.uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
                finish_time = current_time + service_time
                doctor_free_times[next_free_doctor_idx] = finish_time
                last_patient_finish_time = max(last_patient_finish_time, finish_time)
            elif next_arrival_time <= ADMISSIONS_END_TIME:
                current_time = next_arrival_time
                total_patients_arrived += 1
                
                service_time = random.uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
                finish_time = current_time + service_time
                doctor_free_times[next_free_doctor_idx] = finish_time
                last_patient_finish_time = max(last_patient_finish_time, finish_time)
                next_arrival_time += random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
            else:
                break
    return {
        "total_patients": total_patients_arrived,
        "patients_waited": patients_who_waited,
        "total_wait_time": total_wait_time,
        "closing_time": last_patient_finish_time
    }
</code></pre>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- UI Update Functions ---
        const formatTime = (minutes) => {
            if (minutes < 0) return "00:00";
            const total_minutes = Math.round(minutes);
            const hours = Math.floor(total_minutes / 60);
            const mins = total_minutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
        };

        const updateClock = (minutes) => {
            document.getElementById('sim-clock').textContent = `Time: ${formatTime(minutes)}`;
        };

        const updateDoctorsStatus = (doctorFreeTimes, currentTime) => {
            const container = document.getElementById('doctors-status');
            container.innerHTML = '';
            doctorFreeTimes.forEach((freeTime, index) => {
                const isBusy = freeTime > currentTime;
                const statusClass = isBusy ? 'status-busy' : 'status-free';
                const statusText = isBusy ? `BUSY until ${formatTime(freeTime)}` : 'FREE';
                const doctorDiv = document.createElement('div');
                doctorDiv.className = `flex justify-between items-center p-2 rounded-md text-sm ${statusClass}`;
                doctorDiv.innerHTML = `<span class="font-medium">Doctor #${index + 1}</span><span class="text-xs font-semibold">${statusText}</span>`;
                container.appendChild(doctorDiv);
            });
        };

        const updateQueueStatus = (queueSize) => {
            const container = document.getElementById('queue-status');
            container.innerHTML = ''; 
            const textEl = document.createElement('span');
            textEl.id = 'queue-text';
            
            if (queueSize === 0) {
                textEl.textContent = 'Empty';
                textEl.className = 'text-slate-500';
            } else {
                textEl.textContent = `${queueSize} waiting`;
                textEl.className = 'text-slate-700 font-medium mr-2';
            }
            container.appendChild(textEl);
            
            for(let i=0; i < Math.min(queueSize, 12); i++) {
                 const icon = document.createElement('span');
                 icon.title = "Waiting patient";
                 icon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-slate-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" /></svg>`;
                 container.appendChild(icon);
            }
        };
        
        const updateSummaryStats = (stats) => {
            document.getElementById('patient-count').textContent = stats.patientCount;
            document.getElementById('closing-time').textContent = stats.closingTimeStr;
            document.getElementById('total-wait-time').textContent = `${stats.totalWait.toFixed(1)}m`;
            document.getElementById('avg-wait-time').textContent = `${stats.avgWait.toFixed(1)}m`;
        };

        // --- Timeline Functions ---
        const setupTimeline = (events, startTime, endTime) => {
            const timelineBar = document.getElementById('timeline-bar');
            timelineBar.querySelectorAll('.timeline-marker').forEach(m => m.remove());

            document.getElementById('timeline-start-label').textContent = formatTime(startTime);
            document.getElementById('timeline-end-label').textContent = formatTime(endTime);

            const duration = endTime - startTime;
            if (duration <= 0) return;

            events.forEach(event => {
                if (event.type === 'arrival-immediate' || event.type === 'arrival-queue') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.dataset.time = event.time;

                    if (event.type === 'arrival-queue') {
                        marker.classList.add('waited');
                        marker.title = `Patient arrival at ${formatTime(event.time)} (had to wait)`;
                    } else {
                         marker.title = `Patient arrival at ${formatTime(event.time)} (seen immediately)`;
                    }

                    const position = ((event.time - startTime) / duration) * 100;
                    marker.style.left = `${position}%`;
                    timelineBar.appendChild(marker);
                }
            });
        };

        const updateTimelineProgress = (currentTime, startTime, endTime) => {
            const duration = endTime - startTime;
            if (duration <= 0) return;

            const progress = Math.min(((currentTime - startTime) / duration) * 100, 100);
            document.getElementById('timeline-progress').style.width = `${progress}%`;
            
            document.querySelectorAll('.timeline-marker').forEach(marker => {
                if (parseFloat(marker.dataset.time) <= currentTime) {
                    marker.classList.add('active');
                } else {
                    marker.classList.remove('active');
                }
            });
        };


        // --- Event Listener ---
        document.getElementById('run-animation-btn').addEventListener('click', async () => {
            const btn = document.getElementById('run-animation-btn');
            btn.disabled = true;
            btn.textContent = 'Simulating...';

            const { events, endTime } = generateSimulationEvents();
            setupTimeline(events, 9 * 60, endTime);
            await playAnimation(events, endTime);

            btn.disabled = false;
            btn.textContent = 'Run Again';
        });

        // Initialize UI on page load
        document.addEventListener('DOMContentLoaded', () => {
            const SIMULATION_START_TIME = 9 * 60;
            updateClock(SIMULATION_START_TIME);
            updateDoctorsStatus(Array(3).fill(SIMULATION_START_TIME), SIMULATION_START_TIME);
            updateQueueStatus(0);
            updateSummaryStats({ patientCount: 0, closingTimeStr: '--:--', totalWait: 0, avgWait: 0 });
            document.getElementById('timeline-progress').style.width = '0%';
        });
        
        // --- Animation Player ---
        async function playAnimation(events, endTime) {
            const outputElement = document.getElementById('animation-output');
            outputElement.innerHTML = ''; 

            const SIMULATION_START_TIME = 9 * 60;
            updateClock(SIMULATION_START_TIME);
            updateDoctorsStatus(Array(3).fill(SIMULATION_START_TIME), SIMULATION_START_TIME);
            updateQueueStatus(0);
            updateSummaryStats({ patientCount: 0, closingTimeStr: '--:--', totalWait: 0, avgWait: 0 });
            
            await new Promise(resolve => setTimeout(resolve, 500)); 

            for (const event of events) {
                updateClock(event.time);
                updateDoctorsStatus(event.doctorStatus, event.time);
                updateQueueStatus(event.queueSize);
                updateTimelineProgress(event.time, SIMULATION_START_TIME, endTime);
                
                const avgWait = event.patientsWhoWaited > 0 ? event.totalWaitTime / event.patientsWhoWaited : 0;
                updateSummaryStats({
                    patientCount: event.totalPatients,
                    closingTimeStr: '--:--',
                    totalWait: event.totalWaitTime,
                    avgWait: avgWait
                });
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${event.type}`;
                logEntry.textContent = event.message;
                outputElement.appendChild(logEntry);
                outputElement.scrollTop = outputElement.scrollHeight;

                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            const lastEvent = events[events.length - 1];
            if(lastEvent) {
                const finalAvgWait = lastEvent.patientsWhoWaited > 0 ? lastEvent.totalWaitTime / lastEvent.patientsWhoWaited : 0;
                const finalClosingTime = lastEvent.type === 'end' ? lastEvent.time : endTime;
                 updateSummaryStats({
                    patientCount: lastEvent.totalPatients,
                    closingTimeStr: formatTime(finalClosingTime),
                    totalWait: lastEvent.totalWaitTime,
                    avgWait: finalAvgWait
                });
            }
        }

        // --- Simulation Logic (Generates events instead of a single log) ---
        function generateSimulationEvents() {
            const NUM_DOCTORS = 3;
            const MEAN_ARRIVAL_TIME = 10.0;
            const MIN_SERVICE_TIME = 5.0;
            const MAX_SERVICE_TIME = 20.0;
            const SIMULATION_START_TIME = 9 * 60;
            const ADMISSIONS_END_TIME = 16 * 60;

            const expovariate = (mean) => -Math.log(1 - Math.random()) * mean;
            const uniform = (min, max) => Math.random() * (max - min) + min;
            
            let allEvents = [];
            let doctor_free_times = Array(NUM_DOCTORS).fill(SIMULATION_START_TIME);
            let patient_queue = [];
            let next_arrival_time = SIMULATION_START_TIME + expovariate(MEAN_ARRIVAL_TIME);
            
            let total_patients_arrived = 0;
            let total_wait_time = 0.0;
            let patients_who_waited = 0;
            let last_patient_finish_time = SIMULATION_START_TIME;

            allEvents.push({
                time: SIMULATION_START_TIME,
                type: 'start',
                message: `[${formatTime(SIMULATION_START_TIME)}] SIMULATION START. First patient due at ${formatTime(next_arrival_time)}.`,
                doctorStatus: [...doctor_free_times],
                queueSize: 0,
                totalPatients: 0,
                totalWaitTime: 0,
                patientsWhoWaited: 0
            });
            
            while (next_arrival_time <= ADMISSIONS_END_TIME || patient_queue.length > 0) {
                const earliest_free_time = Math.min(...doctor_free_times);
                const next_free_doctor_idx = doctor_free_times.indexOf(earliest_free_time);

                if (next_arrival_time < earliest_free_time && next_arrival_time <= ADMISSIONS_END_TIME) {
                    let current_time = next_arrival_time;
                    total_patients_arrived++;
                    patient_queue.push(current_time);
                    
                    next_arrival_time += expovariate(MEAN_ARRIVAL_TIME);
                    allEvents.push({
                        time: current_time,
                        type: 'arrival-queue',
                        message: `[${formatTime(current_time)}] Patient #${total_patients_arrived} arrives. -> Joins queue.`,
                        doctorStatus: [...doctor_free_times],
                        queueSize: patient_queue.length,
                        totalPatients: total_patients_arrived,
                        totalWaitTime: total_wait_time,
                        patientsWhoWaited: patients_who_waited
                    });
                } else {
                    let current_time = earliest_free_time;
                    if (patient_queue.length > 0) {
                        const patient_arrival_time = patient_queue.shift();
                        const wait_time = current_time - patient_arrival_time;
                        total_wait_time += wait_time;
                        patients_who_waited++;
                        
                        const service_time = uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME);
                        const finish_time = current_time + service_time;
                        doctor_free_times[next_free_doctor_idx] = finish_time;
                        last_patient_finish_time = Math.max(last_patient_finish_time, finish_time);

                        allEvents.push({
                            time: current_time,
                            type: 'service',
                            message: `[${formatTime(current_time)}] Dr. #${next_free_doctor_idx + 1} is free. Sees patient from queue (wait: ${wait_time.toFixed(1)}m). -> Busy until ${formatTime(finish_time)}.`,
                            doctorStatus: [...doctor_free_times],
                            queueSize: patient_queue.length,
                            totalPatients: total_patients_arrived,
                            totalWaitTime: total_wait_time,
                            patientsWhoWaited: patients_who_waited
                        });
                    } else if (next_arrival_time <= ADMISSIONS_END_TIME) {
                        current_time = next_arrival_time;
                        total_patients_arrived++;
                        const service_time = uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME);
                        const finish_time = current_time + service_time;
                        doctor_free_times[next_free_doctor_idx] = finish_time;
                        last_patient_finish_time = Math.max(last_patient_finish_time, finish_time);
                        next_arrival_time += expovariate(MEAN_ARRIVAL_TIME);

                        allEvents.push({
                            time: current_time,
                            type: 'arrival-immediate',
                            message: `[${formatTime(current_time)}] Patient #${total_patients_arrived} arrives. Seen immediately by Dr. #${next_free_doctor_idx + 1}. -> Busy until ${formatTime(finish_time)}.`,
                            doctorStatus: [...doctor_free_times],
                            queueSize: patient_queue.length,
                            totalPatients: total_patients_arrived,
                            totalWaitTime: total_wait_time,
                            patientsWhoWaited: patients_who_waited
                        });
                    } else {
                        const finalClosingTime = Math.max(...doctor_free_times, last_patient_finish_time);
                        allEvents.push({
                            time: finalClosingTime,
                            type: 'end',
                            message: `[${formatTime(finalClosingTime)}] SIMULATION END. Clinic is closed.`,
                            doctorStatus: [...doctor_free_times].map(t => Math.min(t, finalClosingTime)),
                            queueSize: 0,
                            totalPatients: total_patients_arrived,
                            totalWaitTime: total_wait_time,
                            patientsWhoWaited: patients_who_waited
                        });
                        break;
                    }
                }
            }
            if (allEvents[allEvents.length - 1].type !== 'end') {
                 const finalClosingTime = Math.max(last_patient_finish_time, ADMISSIONS_END_TIME);
                 allEvents.push({
                    time: finalClosingTime,
                    type: 'end',
                    message: `[${formatTime(finalClosingTime)}] SIMULATION END. Clinic is closed.`,
                    doctorStatus: [...doctor_free_times].map(t => Math.min(t, finalClosingTime)),
                    queueSize: 0,
                    totalPatients: total_patients_arrived,
                    totalWaitTime: total_wait_time,
                    patientsWhoWaited: patients_who_waited
                });
            }
            return { events: allEvents, endTime: Math.max(last_patient_finish_time, ADMISSIONS_END_TIME) };
        }
    </script>
    <!-- Added Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>

