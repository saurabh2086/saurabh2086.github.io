<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clinic Queuing Problem Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Added Prism CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Adjusted code block padding as Prism adds its own */
        .code-block {
            background-color: #1e293b; /* slate-800 */
            color: #e2e8f0; /* slate-200 */
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        /* Custom styles for animation status */
        .status-free { background-color: #dcfce7; color: #166534; } /* green-100, green-800 */
        .status-busy { background-color: #ffedd5; color: #9a3412; } /* orange-100, orange-800 */
        
        /* Styles for the new timeline */
        .timeline-marker {
            position: absolute;
            top: 50%;
            width: 10px;
            height: 10px;
            background-color: #94a3b8; /* slate-400 */
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: background-color 0.3s ease;
            z-index: 10;
        }
        .timeline-marker.active {
            background-color: #4f46e5; /* indigo-600 */
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-bold text-slate-900">Clinic Queuing Simulation</h1>
            <p class="text-lg text-slate-600 mt-2">An interactive breakdown of a classic queuing problem.</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            
            <!-- Column 1: Problem and Animation -->
            <div class="space-y-8">
                <!-- The Question Card -->
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <h2 class="text-2xl font-semibold mb-4 text-slate-900 border-b pb-2">The Queuing Problem</h2>
                    <div class="prose max-w-none text-slate-700 space-y-4">
                        <p>A clinic has three doctors. Patients come into the clinic at random, starting at 9 a.m., according to a Poisson process with a time parameter of 10 minutes. When a patient arrives, they wait until a doctor is available. The time spent by each doctor with each patient is a random variable, uniformly distributed between 5 and 20 minutes.</p>
                        <p>The office stops admitting new patients at 4 p.m. and closes only when the last patient is finished with their doctor.</p>
                    </div>
                </div>

                <!-- The Animation Card -->
                <div class="bg-white p-6 rounded-lg shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold text-slate-900">Live Simulation</h2>
                        <button id="run-animation-btn" class="bg-indigo-600 text-white font-semibold px-4 py-2 rounded-md hover:bg-indigo-700 transition-colors shadow focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 w-48">
                            Run Animation
                        </button>
                    </div>
                    
                    <!-- Visual Status Display -->
                    <div id="visual-status" class="bg-slate-50 p-4 rounded-md mb-4 border border-slate-200">
                        <div class="flex justify-between items-center text-lg font-semibold mb-3">
                            <span class="text-slate-800">Clinic Status</span>
                            <span id="sim-clock" class="px-3 py-1 bg-slate-200 rounded-full text-sm text-slate-700">Time: 09:00</span>
                        </div>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <h3 class="font-semibold mb-2 text-slate-700">Doctors</h3>
                                <div id="doctors-status" class="space-y-2">
                                    <!-- Doctor divs will be generated by JS -->
                                </div>
                            </div>
                            <div>
                                <h3 class="font-semibold mb-2 text-slate-700">Waiting Queue</h3>
                                <div id="queue-status" class="flex items-center space-x-1 flex-wrap h-16">
                                    <span id="queue-text" class="text-slate-500">Empty</span>
                                </div>
                            </div>
                        </div>
                        <!-- Timeline Section -->
                        <div class="mt-4 pt-4 border-t border-slate-200">
                             <h3 class="font-semibold mb-3 text-slate-700">Patient Arrival Timeline</h3>
                             <div id="timeline-container" class="relative h-10 flex items-center">
                                 <div id="timeline-bar" class="w-full h-2 bg-slate-300 rounded-full relative">
                                     <div id="timeline-progress" class="absolute top-0 left-0 h-2 bg-indigo-400 rounded-full" style="width: 0%;"></div>
                                     <!-- Markers will be added here by JS -->
                                 </div>
                             </div>
                             <div id="timeline-labels" class="flex justify-between w-full text-xs text-slate-500 mt-1 px-1">
                                 <span id="timeline-start-label">9 AM</span>
                                 <span id="timeline-end-label">5 PM</span>
                             </div>
                        </div>
                    </div>

                    <p class="text-slate-600 mb-4">A step-by-step event log of the simulated day.</p>
                    <div id="animation-output" class="code-block h-80 overflow-y-scroll text-sm !p-4">
                        Click "Run Animation" to begin...
                    </div>
                </div>
            </div>

            <!-- Column 2: Python Solution -->
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-semibold mb-4 text-slate-900 border-b pb-2">The Python Solution</h2>
                <div class="code-block text-sm">
<!-- Added language-python class for Prism.js -->
<pre><code class="language-python">
import random
import math
import numpy as np

# --- Simulation Parameters ---
NUM_DOCTORS = 3
MEAN_ARRIVAL_TIME = 10.0
MIN_SERVICE_TIME = 5.0
MAX_SERVICE_TIME = 20.0
SIMULATION_START_TIME = 9 * 60
ADMISSIONS_END_TIME = 16 * 60

# --- Helper Function ---
def format_time(minutes):
    hours = int(minutes // 60)
    mins = int(minutes % 60)
    return f"{hours:02d}:{mins:02d}"

# --- Core Simulation Logic ---
def run_single_simulation():
    doctor_free_times = [SIMULATION_START_TIME] * NUM_DOCTORS
    patient_queue = []
    next_arrival_time = SIMULATION_START_TIME + random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
    
    total_patients_arrived = 0
    patients_who_waited = 0
    total_wait_time = 0.0
    last_patient_finish_time = SIMULATION_START_TIME

    while next_arrival_time <= ADMISSIONS_END_TIME or patient_queue:
        earliest_free_time = min(doctor_free_times)
        next_free_doctor_idx = doctor_free_times.index(earliest_free_time)

        if next_arrival_time < earliest_free_time and next_arrival_time <= ADMISSIONS_END_TIME:
            current_time = next_arrival_time
            total_patients_arrived += 1
            patient_queue.append(current_time)
            next_arrival_time += random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
        else:
            current_time = earliest_free_time
            if patient_queue:
                patient_arrival_time = patient_queue.pop(0)
                wait_time = current_time - patient_arrival_time
                patients_who_waited += 1
                total_wait_time += wait_time
                
                service_time = random.uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
                finish_time = current_time + service_time
                doctor_free_times[next_free_doctor_idx] = finish_time
                last_patient_finish_time = max(last_patient_finish_time, finish_time)
            elif next_arrival_time <= ADMISSIONS_END_TIME:
                current_time = next_arrival_time
                total_patients_arrived += 1
                
                service_time = random.uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME)
                finish_time = current_time + service_time
                doctor_free_times[next_free_doctor_idx] = finish_time
                last_patient_finish_time = max(last_patient_finish_time, finish_time)
                next_arrival_time += random.expovariate(1.0 / MEAN_ARRIVAL_TIME)
            else:
                break
    return {
        "total_patients": total_patients_arrived,
        "patients_waited": patients_who_waited,
        "total_wait_time": total_wait_time,
        "closing_time": last_patient_finish_time
    }
</code></pre>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- UI Update Functions ---
        const formatTime = (minutes) => {
            if (minutes < 0) return "00:00";
            const total_minutes = Math.round(minutes);
            const hours = Math.floor(total_minutes / 60);
            const mins = total_minutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
        };

        const updateClock = (minutes) => {
            document.getElementById('sim-clock').textContent = `Time: ${formatTime(minutes)}`;
        };

        const updateDoctorsStatus = (doctorFreeTimes, currentTime) => {
            const container = document.getElementById('doctors-status');
            container.innerHTML = '';
            doctorFreeTimes.forEach((freeTime, index) => {
                const isBusy = freeTime > currentTime;
                const statusClass = isBusy ? 'status-busy' : 'status-free';
                const statusText = isBusy ? `BUSY until ${formatTime(freeTime)}` : 'FREE';
                const doctorDiv = document.createElement('div');
                doctorDiv.className = `flex justify-between items-center p-2 rounded-md text-sm ${statusClass}`;
                doctorDiv.innerHTML = `<span class="font-medium">Doctor #${index + 1}</span><span class="text-xs font-semibold">${statusText}</span>`;
                container.appendChild(doctorDiv);
            });
        };

        const updateQueueStatus = (queueSize) => {
            const container = document.getElementById('queue-status');
            container.innerHTML = ''; 
            const textEl = document.createElement('span');
            textEl.id = 'queue-text';
            
            if (queueSize === 0) {
                textEl.textContent = 'Empty';
                textEl.className = 'text-slate-500';
            } else {
                textEl.textContent = `${queueSize} waiting`;
                textEl.className = 'text-slate-700 font-medium mr-2';
            }
            container.appendChild(textEl);
            
            for(let i=0; i < Math.min(queueSize, 12); i++) {
                 const icon = document.createElement('span');
                 icon.title = "Waiting patient";
                 icon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-slate-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" /></svg>`;
                 container.appendChild(icon);
            }
        };

        // --- Timeline Functions ---
        const setupTimeline = (events, startTime, endTime) => {
            const timelineBar = document.getElementById('timeline-bar');
            // Clear previous markers
            timelineBar.querySelectorAll('.timeline-marker').forEach(m => m.remove());

            document.getElementById('timeline-start-label').textContent = formatTime(startTime);
            document.getElementById('timeline-end-label').textContent = formatTime(endTime);

            const duration = endTime - startTime;
            if (duration <= 0) return;

            events.forEach(event => {
                if (event.type === 'arrival') {
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.dataset.time = event.time;
                    const position = ((event.time - startTime) / duration) * 100;
                    marker.style.left = `${position}%`;
                    marker.title = `Patient arrival at ${formatTime(event.time)}`;
                    timelineBar.appendChild(marker);
                }
            });
        };

        const updateTimelineProgress = (currentTime, startTime, endTime) => {
            const duration = endTime - startTime;
            if (duration <= 0) return;

            const progress = Math.min(((currentTime - startTime) / duration) * 100, 100);
            document.getElementById('timeline-progress').style.width = `${progress}%`;
            
            // Activate markers that have been passed
            document.querySelectorAll('.timeline-marker').forEach(marker => {
                if (parseFloat(marker.dataset.time) <= currentTime) {
                    marker.classList.add('active');
                } else {
                    marker.classList.remove('active');
                }
            });
        };


        // --- Event Listener ---
        document.getElementById('run-animation-btn').addEventListener('click', async () => {
            const btn = document.getElementById('run-animation-btn');
            btn.disabled = true;
            btn.textContent = 'Simulating...';

            const { events, endTime } = generateSimulationEvents();
            setupTimeline(events, 9 * 60, endTime);
            await playAnimation(events, endTime);

            btn.disabled = false;
            btn.textContent = 'Run Again';
        });

        // Initialize UI on page load
        document.addEventListener('DOMContentLoaded', () => {
            const SIMULATION_START_TIME = 9 * 60;
            updateClock(SIMULATION_START_TIME);
            updateDoctorsStatus(Array(3).fill(SIMULATION_START_TIME), SIMULATION_START_TIME);
            updateQueueStatus(0);
            document.getElementById('timeline-progress').style.width = '0%';
        });
        
        // --- Animation Player ---
        async function playAnimation(events, endTime) {
            const outputElement = document.getElementById('animation-output');
            outputElement.textContent = ''; 

            const SIMULATION_START_TIME = 9 * 60;
            updateClock(SIMULATION_START_TIME);
            updateDoctorsStatus(Array(3).fill(SIMULATION_START_TIME), SIMULATION_START_TIME);
            updateQueueStatus(0);
            
            await new Promise(resolve => setTimeout(resolve, 500)); 

            for (const event of events) {
                updateClock(event.time);
                updateDoctorsStatus(event.doctorStatus, event.time);
                updateQueueStatus(event.queueSize);
                updateTimelineProgress(event.time, SIMULATION_START_TIME, endTime);
                
                const logEntry = document.createElement('div');
                logEntry.className = 'whitespace-pre-wrap';
                logEntry.textContent = event.message;
                outputElement.appendChild(logEntry);
                outputElement.scrollTop = outputElement.scrollHeight;

                await new Promise(resolve => setTimeout(resolve, 400)); // Slower animation speed
            }
        }

        // --- Simulation Logic (Generates events instead of a single log) ---
        function generateSimulationEvents() {
            const NUM_DOCTORS = 3;
            const MEAN_ARRIVAL_TIME = 10.0;
            const MIN_SERVICE_TIME = 5.0;
            const MAX_SERVICE_TIME = 20.0;
            const SIMULATION_START_TIME = 9 * 60;
            const ADMISSIONS_END_TIME = 16 * 60;

            const expovariate = (mean) => -Math.log(1 - Math.random()) * mean;
            const uniform = (min, max) => Math.random() * (max - min) + min;
            
            let allEvents = [];
            let doctor_free_times = Array(NUM_DOCTORS).fill(SIMULATION_START_TIME);
            let patient_queue = [];
            let next_arrival_time = SIMULATION_START_TIME + expovariate(MEAN_ARRIVAL_TIME);
            let total_patients_arrived = 0;
            let last_patient_finish_time = SIMULATION_START_TIME;

            allEvents.push({
                time: SIMULATION_START_TIME,
                type: 'start',
                message: `[${formatTime(SIMULATION_START_TIME)}] SIMULATION START. First patient due at ${formatTime(next_arrival_time)}.`,
                doctorStatus: [...doctor_free_times],
                queueSize: patient_queue.length
            });
            
            while (next_arrival_time <= ADMISSIONS_END_TIME || patient_queue.length > 0) {
                const earliest_free_time = Math.min(...doctor_free_times);
                const next_free_doctor_idx = doctor_free_times.indexOf(earliest_free_time);

                if (next_arrival_time < earliest_free_time && next_arrival_time <= ADMISSIONS_END_TIME) {
                    let current_time = next_arrival_time;
                    total_patients_arrived++;
                    patient_queue.push(current_time);
                    
                    next_arrival_time += expovariate(MEAN_ARRIVAL_TIME);
                    allEvents.push({
                        time: current_time,
                        type: 'arrival',
                        message: `[${formatTime(current_time)}] Patient #${total_patients_arrived} arrives. All doctors busy. -> Joins queue.`,
                        doctorStatus: [...doctor_free_times],
                        queueSize: patient_queue.length
                    });
                } else {
                    let current_time = earliest_free_time;
                    if (patient_queue.length > 0) {
                        const patient_arrival_time = patient_queue.shift();
                        const wait_time = current_time - patient_arrival_time;
                        const service_time = uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME);
                        const finish_time = current_time + service_time;
                        doctor_free_times[next_free_doctor_idx] = finish_time;
                        last_patient_finish_time = Math.max(last_patient_finish_time, finish_time);

                        allEvents.push({
                            time: current_time,
                            type: 'service_from_queue',
                            message: `[${formatTime(current_time)}] Dr. #${next_free_doctor_idx + 1} is free. Sees patient from queue (wait: ${wait_time.toFixed(1)}m). -> Busy until ${formatTime(finish_time)}.`,
                            doctorStatus: [...doctor_free_times],
                            queueSize: patient_queue.length
                        });
                    } else if (next_arrival_time <= ADMISSIONS_END_TIME) {
                        current_time = next_arrival_time;
                        total_patients_arrived++;
                        const service_time = uniform(MIN_SERVICE_TIME, MAX_SERVICE_TIME);
                        const finish_time = current_time + service_time;
                        doctor_free_times[next_free_doctor_idx] = finish_time;
                        last_patient_finish_time = Math.max(last_patient_finish_time, finish_time);
                        next_arrival_time += expovariate(MEAN_ARRIVAL_TIME);

                        allEvents.push({
                            time: current_time,
                            type: 'arrival', // It's an arrival and immediate service
                            message: `[${formatTime(current_time)}] Patient #${total_patients_arrived} arrives. Seen immediately by Dr. #${next_free_doctor_idx + 1}. -> Busy until ${formatTime(finish_time)}.`,
                            doctorStatus: [...doctor_free_times],
                            queueSize: patient_queue.length
                        });
                    } else {
                        allEvents.push({
                            time: current_time,
                            type: 'end',
                            message: `[${formatTime(current_time)}] SIMULATION END. Admissions closed and queue is empty.`,
                            doctorStatus: [...doctor_free_times],
                            queueSize: patient_queue.length
                        });
                        break;
                    }
                }
            }
            return { events: allEvents, endTime: Math.max(last_patient_finish_time, ADMISSIONS_END_TIME) };
        }
    </script>
    <!-- Added Prism JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>

